#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# MLDataHub
# Copyright (C) 2017 Iván de Paz Centeno <ipazc@unileon.es>.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; version 3
# of the License or (at your option) any later version of
# the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA  02110-1301, USA.

from contextlib import contextmanager
import datetime
from dateutil.relativedelta import relativedelta

__author__ = 'Iván de Paz Centeno'


def time_left_as_str(seconds):
    """
    Converts a seconds into the format [X]h [Y]m [Z]s
    :param seconds: integer with the number of seconds to parse
    :return: string with the format [X]h [Y]m [Z]s. For example: 5h 30m 10s
    """
    result = []

    t = ["s", "m", "h"]
    d = [60, 60, 24]

    for m, n in zip(t, d):

        v = seconds % n
        seconds //= n

        result.append("{:02}{}".format(int(v), m))

    return " ".join(result[::-1])


def now():
    """
    The datetime as of now.
    Example result:
        datetime.datetime(2017, 11, 27, 10, 44, 0, 201299)

    if converted to str:
        '2017-11-27 10:44:03.841595'
    :return:
    """
    return datetime.datetime.now()


def token_future_end():
    """
    Default token expire date from now (+500 years)
    :return: Date in 500 years from now.
    """
    return now() + relativedelta(years=+500)


class TimeMeasurement():
    """
    Class for measuring the time.
    """
    def __init__(self, delta: datetime.timedelta):
        """
        Initializes the time measurement class with a given delta.
        :param delta: timedelta from datetime. It can be generated by substracting two datetime objects.
        """
        self.delta = delta

    @property
    def days(self):
        """
        :return: total days of the delta.
        """
        return self.delta.days + self.delta.seconds/60/60/24 + self.delta.microseconds/1000/1000/60/60/24

    @property
    def hours(self):
        """
        :return: total hours of the delta
        """
        return self.delta.days*24 + self.delta.seconds/60/60 + self.delta.microseconds/1000/1000/60/60

    @property
    def minutes(self):
        """
        :return: total minutes of the delta
        """
        return self.delta.days*24*60 + self.delta.seconds/60 + self.delta.microseconds/1000/1000/60

    @property
    def seconds(self):
        """
        :return: total seconds of the delta
        """
        return self.delta.days*24*60*60 + self.delta.seconds + self.delta.microseconds/1000/1000

    @property
    def milliseconds(self):
        """
        :return: total milliseconds of the delta
        """
        return self.delta.days*24*60*60*1000 + self.delta.seconds*1000 + self.delta.microseconds/1000


class Chronometer(object):
    """
    Class that allows to measure the time between two milestones.
    """
    def __init__(self, time):
        self.time = time

    def elapsed(self):
        return TimeMeasurement(now() - self.time)

    def reset(self):
        self.time = now()

@contextmanager
def Measure():
    """
    Contextmanager to measure time between two events.
    Example of use:

    with Measure() as timing:
        {do complex work}
        print("Time passed: {}".format(timing.elapsed())
    """
    time = now()
    yield Chronometer(time)
